diff -rwu monero/src/cryptonote_core/tx_pool.cpp monero-offshore/src/cryptonote_core/tx_pool.cpp
--- monero/src/cryptonote_core/tx_pool.cpp	2019-09-02 10:05:52.557716211 +0100
+++ monero-offshore/src/cryptonote_core/tx_pool.cpp	2019-08-20 10:48:12.452576399 +0100
@@ -82,8 +82,8 @@
 
     uint64_t get_transaction_weight_limit(uint8_t version)
     {
-      // from v8, limit a tx to 50% of the minimum block weight
-      if (version >= 8)
+      // from v5, limit a tx to 50% of the minimum block weight
+      if (version >= 5)
         return get_min_block_weight(version) / 2 - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
       else
         return get_min_block_weight(version) - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
@@ -413,6 +413,7 @@
   //---------------------------------------------------------------------------------
   bool tx_memory_pool::insert_key_images(const transaction_prefix &tx, const crypto::hash &id, bool kept_by_block)
   {
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
     for(const auto& in: tx.vin)
     {
       CHECKED_GET_SPECIFIC_VARIANT(in, const txin_to_key, txin, false);
@@ -423,6 +424,31 @@
       auto ins_res = kei_image_set.insert(id);
       CHECK_AND_ASSERT_MES(ins_res.second, false, "internal error: try to insert duplicate iterator in key_image set");
     }
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(const auto& in: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(in, const txin_offshore, txin, false);
+	  std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+	  CHECK_AND_ASSERT_MES(kept_by_block || kei_image_set.size() == 0, false, "internal error: kept_by_block=" << kept_by_block
+			       << ",  kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
+			       << "tx_id=" << id );
+	  auto ins_res = kei_image_set.insert(id);
+	  CHECK_AND_ASSERT_MES(ins_res.second, false, "internal error: try to insert duplicate iterator in key_image set");
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(const auto& in: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(in, const txin_onshore, txin, false);
+	  std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+	  CHECK_AND_ASSERT_MES(kept_by_block || kei_image_set.size() == 0, false, "internal error: kept_by_block=" << kept_by_block
+			       << ",  kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
+			       << "tx_id=" << id );
+	  auto ins_res = kei_image_set.insert(id);
+	  CHECK_AND_ASSERT_MES(ins_res.second, false, "internal error: try to insert duplicate iterator in key_image set");
+	}
+    }
     ++m_cookie;
     return true;
   }
@@ -435,9 +461,10 @@
     CRITICAL_REGION_LOCAL(m_transactions_lock);
     CRITICAL_REGION_LOCAL1(m_blockchain);
     // ND: Speedup
+    if (tx.vin[0].type() == typeid(txin_onshore)) {
     for(const txin_v& vi: tx.vin)
     {
-      CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_to_key, txin, false);
+	  CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_onshore, txin, false);
       auto it = m_spent_key_images.find(txin.k_image);
       CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
                                     << "transaction id = " << actual_hash);
@@ -454,7 +481,51 @@
         //it is now empty hash container for this key_image
         m_spent_key_images.erase(it);
       }
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(const txin_v& vi: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_offshore, txin, false);
+	  auto it = m_spent_key_images.find(txin.k_image);
+	  CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  std::unordered_set<crypto::hash>& key_image_set =  it->second;
+	  CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
 
+	  auto it_in_set = key_image_set.find(actual_hash);
+	  CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  key_image_set.erase(it_in_set);
+	  if(!key_image_set.size())
+	    {
+	      //it is now empty hash container for this key_image
+	      m_spent_key_images.erase(it);
+	    }
+	}
+    }
+    else {
+      for(const txin_v& vi: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_to_key, txin, false);
+	  auto it = m_spent_key_images.find(txin.k_image);
+	  CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  std::unordered_set<crypto::hash>& key_image_set =  it->second;
+	  CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+
+	  auto it_in_set = key_image_set.find(actual_hash);
+	  CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  key_image_set.erase(it_in_set);
+	  if(!key_image_set.size())
+	    {
+	      //it is now empty hash container for this key_image
+	      m_spent_key_images.erase(it);
+	    }
+	}
     }
     ++m_cookie;
     return true;
@@ -957,12 +1028,30 @@
   {
     CRITICAL_REGION_LOCAL(m_transactions_lock);
     CRITICAL_REGION_LOCAL1(m_blockchain);
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
     for(const auto& in: tx.vin)
     {
       CHECKED_GET_SPECIFIC_VARIANT(in, const txin_to_key, tokey_in, true);//should never fail
       if(have_tx_keyimg_as_spent(tokey_in.k_image))
          return true;
     }
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(const auto& in: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(in, const txin_offshore, tokey_in, true);//should never fail
+	  if(have_tx_keyimg_as_spent(tokey_in.k_image))
+	    return true;
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(const auto& in: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(in, const txin_onshore, tokey_in, true);//should never fail
+	  if(have_tx_keyimg_as_spent(tokey_in.k_image))
+	    return true;
+	}
+    }
     return false;
   }
   //---------------------------------------------------------------------------------
@@ -1070,23 +1159,59 @@
   //---------------------------------------------------------------------------------
   bool tx_memory_pool::have_key_images(const std::unordered_set<crypto::key_image>& k_images, const transaction_prefix& tx)
   {
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
     for(size_t i = 0; i!= tx.vin.size(); i++)
     {
       CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, false);
       if(k_images.count(itk.k_image))
         return true;
     }
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_offshore, itk, false);
+	  if(k_images.count(itk.k_image))
+	    return true;
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_onshore, itk, false);
+	  if(k_images.count(itk.k_image))
+	    return true;
+	}
+    }
     return false;
   }
   //---------------------------------------------------------------------------------
   bool tx_memory_pool::append_key_images(std::unordered_set<crypto::key_image>& k_images, const transaction_prefix& tx)
   {
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
     for(size_t i = 0; i!= tx.vin.size(); i++)
     {
       CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, false);
       auto i_res = k_images.insert(itk.k_image);
       CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
     }
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_offshore, itk, false);
+	  auto i_res = k_images.insert(itk.k_image);
+	  CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_onshore, itk, false);
+	  auto i_res = k_images.insert(itk.k_image);
+	  CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+	}
+    }
     return true;
   }
   //---------------------------------------------------------------------------------
@@ -1098,8 +1223,18 @@
     LockedTXN lock(m_blockchain);
     for(size_t i = 0; i!= tx.vin.size(); i++)
     {
+      crypto::key_image itk_key_image;
+      if (tx.vin[i].type() == typeid(txin_to_key)) {
       CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, void());
-      const key_images_container::const_iterator it = m_spent_key_images.find(itk.k_image);
+        itk_key_image = itk.k_image;
+      } else if (tx.vin[i].type() == typeid(txin_onshore)) {
+	CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_onshore, itk, void());
+        itk_key_image = itk.k_image;
+      } else {
+	CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_offshore, itk, void());
+        itk_key_image = itk.k_image;
+      }
+      const key_images_container::const_iterator it = m_spent_key_images.find(itk_key_image);
       if (it != m_spent_key_images.end())
       {
         for (const crypto::hash &txid: it->second)
@@ -1113,7 +1248,7 @@
           }
           if (!meta.double_spend_seen)
           {
-            MDEBUG("Marking " << txid << " as double spending " << itk.k_image);
+            MDEBUG("Marking " << txid << " as double spending " << itk_key_image);
             meta.double_spend_seen = true;
             changed = true;
             try
