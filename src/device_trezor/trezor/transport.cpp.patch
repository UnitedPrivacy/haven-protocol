--- monero/src/device_trezor/trezor/transport.cpp	2019-06-20 21:03:18.754816404 +0100
+++ haven/src/device_trezor/trezor/transport.cpp	2019-05-30 17:58:17.133592153 +0100
@@ -1,4 +1,4 @@
-// Copyright (c) 2017-2019, The Monero Project
+// Copyright (c) 2017-2018, The Monero Project
 //
 // All rights reserved.
 //
@@ -31,13 +31,11 @@
 #include <libusb.h>
 #endif
 
-#include <algorithm>
 #include <boost/endian/conversion.hpp>
 #include <boost/asio/io_service.hpp>
 #include <boost/asio/ip/udp.hpp>
 #include <boost/date_time/posix_time/posix_time_types.hpp>
 #include <boost/format.hpp>
-#include "common/apply_permutation.h"
 #include "transport.hpp"
 #include "messages/messages-common.pb.h"
 
@@ -86,58 +84,6 @@
     return std::string(in.GetString());
   }
 
-  uint64_t pack_version(uint32_t major, uint32_t minor, uint32_t patch)
-  {
-    // packing (major, minor, patch) to 64 B: 16 B | 24 B | 24 B
-    const unsigned bits_1 = 16;
-    const unsigned bits_2 = 24;
-    const uint32_t mask_1 = (1 << bits_1) - 1;
-    const uint32_t mask_2 = (1 << bits_2) - 1;
-    CHECK_AND_ASSERT_THROW_MES(major <= mask_1 && minor <= mask_2 && patch <= mask_2, "Version numbers overflow packing scheme");
-    return patch | (((uint64_t)minor) << bits_2) | (((uint64_t)major) << (bits_1 + bits_2));
-  }
-
-  typedef struct {
-    uint16_t trezor_type;
-    uint16_t id_vendor;
-    uint16_t id_product;
-  } trezor_usb_desc_t;
-
-  static trezor_usb_desc_t TREZOR_DESC_T1 = {1, 0x534C, 0x0001};
-  static trezor_usb_desc_t TREZOR_DESC_T2 = {2, 0x1209, 0x53C1};
-  static trezor_usb_desc_t TREZOR_DESC_T2_BL = {3, 0x1209, 0x53C0};
-
-  static trezor_usb_desc_t TREZOR_DESCS[] = {
-      TREZOR_DESC_T1,
-      TREZOR_DESC_T2,
-      TREZOR_DESC_T2_BL,
-  };
-
-  static size_t TREZOR_DESCS_LEN = sizeof(TREZOR_DESCS)/sizeof(TREZOR_DESCS[0]);
-
-  static ssize_t get_device_idx(uint16_t id_vendor, uint16_t id_product){
-    for(size_t i = 0; i < TREZOR_DESCS_LEN; ++i){
-      if (TREZOR_DESCS[i].id_vendor == id_vendor && TREZOR_DESCS[i].id_product == id_product){
-        return i;
-      }
-    }
-
-    return -1;
-  }
-
-  static bool is_device_supported(ssize_t device_idx){
-    CHECK_AND_ASSERT_THROW_MES(device_idx < (ssize_t)TREZOR_DESCS_LEN, "Device desc idx too big");
-    if (device_idx < 0){
-      return false;
-    }
-
-#ifdef TREZOR_1_SUPPORTED
-    return true;
-#else
-    return TREZOR_DESCS[device_idx].trezor_type != 1;
-#endif
-  }
-
   //
   // Helpers
   //
@@ -266,74 +212,12 @@
     msg = msg_wrap;
   }
 
-  static void assert_port_number(uint32_t port)
-  {
-    CHECK_AND_ASSERT_THROW_MES(port >= 1024 && port < 65535, "Invalid port number: " << port);
-  }
-
-  Transport::Transport(): m_open_counter(0) {
-
-  }
-
-  bool Transport::pre_open(){
-    if (m_open_counter > 0){
-      MTRACE("Already opened, count: " << m_open_counter);
-      m_open_counter += 1;
-      return false;
-
-    } else if (m_open_counter < 0){
-      MTRACE("Negative open value: " << m_open_counter);
-
-    }
-
-    // Caller should set m_open_counter to 1 after open
-    m_open_counter = 0;
-    return true;
-  }
-
-  bool Transport::pre_close(){
-    m_open_counter -= 1;
-
-    if (m_open_counter < 0){
-      MDEBUG("Already closed. Counter " << m_open_counter);
-
-    } else if (m_open_counter == 0) {
-      return true;
-
-    }
-
-    return false;
-  }
-
   //
   // Bridge transport
   //
 
   const char * BridgeTransport::PATH_PREFIX = "bridge:";
 
-  BridgeTransport::BridgeTransport(
-        boost::optional<std::string> device_path,
-        boost::optional<std::string> bridge_host):
-    m_device_path(device_path),
-    m_bridge_host(bridge_host ? bridge_host.get() : DEFAULT_BRIDGE),
-    m_response(boost::none),
-    m_session(boost::none),
-    m_device_info(boost::none)
-    {
-      const char *env_bridge_port = nullptr;
-      if (!bridge_host && (env_bridge_port = getenv("TREZOR_BRIDGE_PORT")) != nullptr)
-      {
-        uint16_t bridge_port;
-        CHECK_AND_ASSERT_THROW_MES(epee::string_tools::get_xtype_from_string(bridge_port, env_bridge_port), "Invalid bridge port: " << env_bridge_port);
-        assert_port_number(bridge_port);
-
-        m_bridge_host = std::string("127.0.0.1:") + boost::lexical_cast<std::string>(env_bridge_port);
-        MDEBUG("Bridge host: " << m_bridge_host);
-      }
-
-      m_http_client.set_server(m_bridge_host, boost::none, epee::net_utils::ssl_support_t::e_ssl_support_disabled);
-    }
-
   std::string BridgeTransport::get_path() const {
     if (!m_device_path){
       return "";
@@ -355,24 +239,6 @@
     for(rapidjson::Value::ConstValueIterator itr = bridge_res.Begin(); itr != bridge_res.End(); ++itr){
       auto element = itr->GetObject();
       auto t = std::make_shared<BridgeTransport>(boost::make_optional(json_get_string(element["path"])));
-
-      auto itr_vendor = element.FindMember("vendor");
-      auto itr_product = element.FindMember("product");
-      if (itr_vendor != element.MemberEnd() && itr_product != element.MemberEnd()
-        && itr_vendor->value.IsNumber() && itr_product->value.IsNumber()){
-        try {
-          const auto id_vendor = (uint16_t) itr_vendor->value.GetUint64();
-          const auto id_product = (uint16_t) itr_product->value.GetUint64();
-          const auto device_idx = get_device_idx(id_vendor, id_product);
-          if (!is_device_supported(device_idx)){
-            MDEBUG("Device with idx " << device_idx << " is not supported. Vendor: " << id_vendor << ", product: " << id_product);
-            continue;
-          }
-        } catch(const std::exception &e){
-          MERROR("Could not detect vendor & product: " << e.what());
-        }
-      }
-
       t->m_device_info.emplace();
       t->m_device_info->CopyFrom(*itr, t->m_device_info->GetAllocator());
       res.push_back(t);
@@ -380,10 +246,6 @@
   }
 
   void BridgeTransport::open() {
-    if (!pre_open()){
-      return;
-    }
-
     if (!m_device_path){
       throw exc::CommunicationException("Coud not open, empty device path");
     }
@@ -397,15 +259,9 @@
     }
 
     m_session = boost::make_optional(json_get_string(bridge_res["session"]));
-    m_open_counter = 1;
   }
 
   void BridgeTransport::close() {
-    if (!pre_close()){
-      return;
-    }
-
-    MTRACE("Closing Trezor:BridgeTransport");
     if (!m_device_path || !m_session){
       throw exc::CommunicationException("Device not open");
     }
@@ -490,40 +346,28 @@
   const char * UdpTransport::DEFAULT_HOST = "127.0.0.1";
   const int UdpTransport::DEFAULT_PORT = 21324;
 
-  static void parse_udp_path(std::string &host, int &port, std::string path)
-  {
-    if (boost::starts_with(path, UdpTransport::PATH_PREFIX))
-    {
-      path = path.substr(strlen(UdpTransport::PATH_PREFIX));
-    }
-
-    auto delim = path.find(':');
-    if (delim == std::string::npos) {
-      host = path;
-    } else {
-      host = path.substr(0, delim);
-      port = std::stoi(path.substr(delim + 1));
-    }
-  }
-
   UdpTransport::UdpTransport(boost::optional<std::string> device_path,
                              boost::optional<std::shared_ptr<Protocol>> proto) :
       m_io_service(), m_deadline(m_io_service)
   {
-    m_device_host = DEFAULT_HOST;
     m_device_port = DEFAULT_PORT;
-    const char *env_trezor_path = nullptr;
-
     if (device_path) {
-      parse_udp_path(m_device_host, m_device_port, device_path.get());
-    } else if ((env_trezor_path = getenv("TREZOR_PATH")) != nullptr && boost::starts_with(env_trezor_path, UdpTransport::PATH_PREFIX)){
-      parse_udp_path(m_device_host, m_device_port, std::string(env_trezor_path));
-      MDEBUG("Applied TREZOR_PATH: " << m_device_host << ":" << m_device_port);
+      const std::string device_str = device_path.get();
+      auto delim = device_str.find(':');
+      if (delim == std::string::npos) {
+        m_device_host = device_str;
+      } else {
+        m_device_host = device_str.substr(0, delim);
+        m_device_port = std::stoi(device_str.substr(delim + 1));
+      }
     } else {
       m_device_host = DEFAULT_HOST;
     }
 
-    assert_port_number((uint32_t)m_device_port);
+    if (m_device_port <= 1024 || m_device_port > 65535){
+      throw std::invalid_argument("Port number invalid");
+    }
+
     if (m_device_host != "localhost" && m_device_host != DEFAULT_HOST){
       throw std::invalid_argument("Local endpoint allowed only");
     }
@@ -579,10 +423,6 @@
   }
 
   void UdpTransport::open() {
-    if (!pre_open()){
-      return;
-    }
-
     udp::resolver resolver(m_io_service);
     udp::resolver::query query(udp::v4(), m_device_host, std::to_string(m_device_port));
     m_endpoint = *resolver.resolve(query);
@@ -594,16 +434,10 @@
     check_deadline();
 
     m_proto->session_begin(*this);
-    m_open_counter = 1;
   }
 
   void UdpTransport::close() {
-    if (!pre_close()){
-      return;
-    }
-
-    MTRACE("Closing Trezor:UdpTransport");
-    if (!m_socket) {
+    if (!m_socket){
       throw exc::CommunicationException("Socket is already closed");
     }
 
@@ -612,19 +446,6 @@
     m_socket = nullptr;
   }
 
-  std::shared_ptr<Transport> UdpTransport::find_debug() {
-#ifdef WITH_TREZOR_DEBUGGING
-    std::shared_ptr<UdpTransport> t = std::make_shared<UdpTransport>();
-    t->m_proto = std::make_shared<ProtocolV1>();
-    t->m_device_host = m_device_host;
-    t->m_device_port = m_device_port + 1;
-    return t;
-#else
-    MINFO("Debug link is disabled in production");
-    return nullptr;
-#endif
-  }
-
   void UdpTransport::write_chunk(const void * buff, size_t size){
     require_socket();
 
@@ -771,20 +592,24 @@
 #ifdef WITH_DEVICE_TREZOR_WEBUSB
 
   static bool is_trezor1(libusb_device_descriptor * info){
-    return info->idVendor == TREZOR_DESC_T1.id_vendor && info->idProduct == TREZOR_DESC_T1.id_product;
+    return info->idVendor == 0x534C && info->idProduct == 0x0001;
   }
 
   static bool is_trezor2(libusb_device_descriptor * info){
-    return info->idVendor == TREZOR_DESC_T2.id_vendor && info->idProduct == TREZOR_DESC_T2.id_product;
+    return info->idVendor == 0x1209 && info->idProduct == 0x53C1;
   }
 
   static bool is_trezor2_bl(libusb_device_descriptor * info){
-    return info->idVendor == TREZOR_DESC_T2_BL.id_vendor && info->idProduct == TREZOR_DESC_T2_BL.id_product;
+    return info->idVendor == 0x1209 && info->idProduct == 0x53C0;
   }
 
-  static ssize_t get_trezor_dev_id(libusb_device_descriptor *info){
+  static uint8_t get_trezor_dev_mask(libusb_device_descriptor * info){
+    uint8_t mask = 0;
     CHECK_AND_ASSERT_THROW_MES(info, "Empty device descriptor");
-    return get_device_idx(info->idVendor, info->idProduct);
+    mask |= is_trezor1(info) ? 1 : 0;
+    mask |= is_trezor2(info) ? 2 : 0;
+    mask |= is_trezor2_bl(info) ? 4 : 0;
+    return mask;
   }
 
   static void set_libusb_log(libusb_context *ctx){
@@ -835,7 +660,8 @@
   WebUsbTransport::WebUsbTransport(
       boost::optional<libusb_device_descriptor*> descriptor,
       boost::optional<std::shared_ptr<Protocol>> proto
-  ): m_usb_session(nullptr), m_usb_device(nullptr), m_usb_device_handle(nullptr),
+  ): m_conn_count(0),
+     m_usb_session(nullptr), m_usb_device(nullptr), m_usb_device_handle(nullptr),
      m_bus_id(-1), m_device_addr(-1)
   {
     if (descriptor){
@@ -846,7 +672,7 @@
 
     m_proto = proto ? proto.get() : std::make_shared<ProtocolV1>();
 
-#ifdef WITH_TREZOR_DEBUGGING
+#ifdef WITH_TREZOR_DEBUG
     m_debug_mode = false;
 #endif
   }
@@ -901,12 +727,12 @@
         continue;
       }
 
-      const auto trezor_dev_idx = get_trezor_dev_id(&desc);
-      if (!is_device_supported(trezor_dev_idx)){
+      const auto trezor_mask = get_trezor_dev_mask(&desc);
+      if (!trezor_mask){
         continue;
       }
 
-      MTRACE("Found Trezor device: " << desc.idVendor << ":" << desc.idProduct << " dev_idx " << (int)trezor_dev_idx);
+      MTRACE("Found Trezor device: " << desc.idVendor << ":" << desc.idProduct << " mask " << (int)trezor_mask);
 
       auto t = std::make_shared<WebUsbTransport>(boost::make_optional(&desc));
       t->m_bus_id = libusb_get_bus_number(devs[i]);
@@ -931,10 +757,12 @@
   };
 
   void WebUsbTransport::open() {
-    if (!pre_open()){
+    const int interface = get_interface();
+    if (m_conn_count > 0){
+      MTRACE("Already opened, count: " << m_conn_count);
+      m_conn_count += 1;
       return;
     }
-    const int interface = get_interface();
 
 #define TREZOR_DESTROY_SESSION() do { libusb_exit(m_usb_session); m_usb_session = nullptr; } while(0)
 
@@ -966,8 +794,8 @@
         continue;
       }
 
-      const auto trezor_dev_idx = get_trezor_dev_id(&desc);
-      if (!is_device_supported(trezor_dev_idx)){
+      const auto trezor_mask = get_trezor_dev_mask(&desc);
+      if (!trezor_mask) {
         continue;
       }
 
@@ -978,7 +806,7 @@
       get_libusb_ports(devs[i], path);
 
       MTRACE("Found Trezor device: " << desc.idVendor << ":" << desc.idProduct
-                                     << ", dev_idx: " << (int)trezor_dev_idx
+                                     << ", mask: " << (int)trezor_mask
                                      << ". path: " << get_usb_path(bus_id, path));
 
       if (bus_id == m_bus_id && path == m_port_numbers) {
@@ -1012,55 +840,45 @@
       throw exc::DeviceAcquireException("Unable to claim libusb device");
     }
 
-    m_open_counter = 1;
+    m_conn_count = 1;
     m_proto->session_begin(*this);
     
 #undef TREZOR_DESTROY_SESSION
   };
 
   void WebUsbTransport::close() {
-    if (!pre_close()){
-      return;
-    }
+    m_conn_count -= 1;
 
-    MTRACE("Closing Trezor:WebUsbTransport");
-    m_proto->session_end(*this);
+    if (m_conn_count < 0){
+      MERROR("Close counter is negative: " << m_conn_count);
 
-    int r = libusb_release_interface(m_usb_device_handle, get_interface());
-    if (r != 0){
-      MERROR("Could not release libusb interface: " << r);
-    }
+    } else if (m_conn_count == 0){
+      MTRACE("Closing webusb device");
 
-    m_usb_device = nullptr;
-    if (m_usb_device_handle) {
-      libusb_close(m_usb_device_handle);
-      m_usb_device_handle = nullptr;
-    }
+      m_proto->session_end(*this);
 
-    if (m_usb_session) {
-      libusb_exit(m_usb_session);
-      m_usb_session = nullptr;
+      int r = libusb_release_interface(m_usb_device_handle, get_interface());
+      if (r != 0){
+        MERROR("Could not release libusb interface: " << r);
+      }
+
+      m_usb_device = nullptr;
+      if (m_usb_device_handle) {
+        libusb_close(m_usb_device_handle);
+        m_usb_device_handle = nullptr;
+      }
+
+      if (m_usb_session) {
+        libusb_exit(m_usb_session);
+        m_usb_session = nullptr;
+      }
     }
   };
 
-  std::shared_ptr<Transport> WebUsbTransport::find_debug() {
-#ifdef WITH_TREZOR_DEBUGGING
-    require_device();
-    auto t = std::make_shared<WebUsbTransport>(boost::make_optional(m_usb_device_desc.get()));
-    t->m_bus_id = m_bus_id;
-    t->m_device_addr = m_device_addr;
-    t->m_port_numbers = m_port_numbers;
-    t->m_debug_mode = true;
-    return t;
-#else
-      MINFO("Debug link is disabled in production");
-      return nullptr;
-#endif
-    }
 
   int WebUsbTransport::get_interface() const{
     const int INTERFACE_NORMAL = 0;
-#ifdef WITH_TREZOR_DEBUGGING
+#ifdef WITH_TREZOR_DEBUG
     const int INTERFACE_DEBUG = 1;
     return m_debug_mode ? INTERFACE_DEBUG : INTERFACE_NORMAL;
 #else
@@ -1070,7 +888,7 @@
 
   unsigned char WebUsbTransport::get_endpoint() const{
     const unsigned char ENDPOINT_NORMAL = 1;
-#ifdef WITH_TREZOR_DEBUGGING
+#ifdef WITH_TREZOR_DEBUG
     const unsigned char ENDPOINT_DEBUG = 2;
     return m_debug_mode ? ENDPOINT_DEBUG : ENDPOINT_NORMAL;
 #else
@@ -1167,39 +985,6 @@
 #endif
   }
 
-  void sort_transports_by_env(t_transport_vect & res){
-    const char *env_trezor_path = getenv("TREZOR_PATH");
-    if (!env_trezor_path){
-      return;
-    }
-    
-    // Sort transports by the longest matching prefix with TREZOR_PATH
-    std::string trezor_path(env_trezor_path);
-    std::vector<size_t> match_idx(res.size());
-    std::vector<size_t> path_permutation(res.size());
-
-    for(size_t i = 0; i < res.size(); ++i){
-      auto cpath = res[i]->get_path();
-      std::string * s1 = &trezor_path;
-      std::string * s2 = &cpath;
-      
-      // first has to be shorter in std::mismatch(). Returns first non-matching iterators.
-      if (s1->size() >= s2->size()){
-        std::swap(s1, s2);
-      }
-
-      const auto mism = std::mismatch(s1->begin(), s1->end(), s2->begin());
-      match_idx[i] = mism.first - s1->begin();
-      path_permutation[i] = i;
-    }
-
-    std::sort(path_permutation.begin(), path_permutation.end(), [&](const size_t i0, const size_t i1) {
-      return match_idx[i0] > match_idx[i1];
-    });
-
-    tools::apply_permutation(path_permutation, res);
-  }
-
   std::shared_ptr<Transport> transport(const std::string & path){
     if (boost::starts_with(path, BridgeTransport::PATH_PREFIX)){
       return std::make_shared<BridgeTransport>(path.substr(strlen(BridgeTransport::PATH_PREFIX)));
@@ -1262,3 +1047,4 @@
 }
 }
 
+
