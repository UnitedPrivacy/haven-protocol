--- monero/src/device_trezor/device_trezor.cpp	2019-06-20 21:03:18.742816503 +0100
+++ haven/src/device_trezor/device_trezor.cpp	2019-05-30 17:58:17.129592192 +0100
@@ -312,160 +187,27 @@
         }
 
         MTRACE("Batch " << cur << " / " << num_batches << " batches processed");
-        EVENT_PROGRESS((double)cur * batch_size / mtds.size());
       }
-      EVENT_PROGRESS(1.);
 
       auto final_req = std::make_shared<messages::monero::MoneroKeyImageSyncFinalRequest>();
       auto final_ack = this->client_exchange<messages::monero::MoneroKeyImageSyncFinalAck>(final_req);
       ski.reserve(kis.size());
 
       for(auto & sub : kis){
-        ::crypto::signature sig{};
-        ::crypto::key_image ki;
-        char buff[sizeof(ki.data)*3];
-
-        size_t buff_len = sizeof(buff);
-
+        char buff[32*3];
         protocol::crypto::chacha::decrypt(sub.blob().data(), sub.blob().size(),
                                           reinterpret_cast<const uint8_t *>(final_ack->enc_key().data()),
-                                          reinterpret_cast<const uint8_t *>(sub.iv().data()), buff, &buff_len);
-        CHECK_AND_ASSERT_THROW_MES(buff_len == sizeof(buff), "Plaintext size invalid");
+                                          reinterpret_cast<const uint8_t *>(sub.iv().data()), buff);
 
-        memcpy(ki.data, buff, sizeof(ki.data));
-        memcpy(sig.c.data, buff + sizeof(ki.data), sizeof(ki.data));
-        memcpy(sig.r.data, buff + 2*sizeof(ki.data), sizeof(ki.data));
+        ::crypto::signature sig{};
+        ::crypto::key_image ki;
+        memcpy(ki.data, buff, 32);
+        memcpy(sig.c.data, buff + 32, 32);
+        memcpy(sig.r.data, buff + 64, 32);
         ski.push_back(std::make_pair(ki, sig));
       }
-#undef EVENT_PROGRESS
     }
 
-    bool device_trezor::is_live_refresh_supported() const
-    {
-      require_initialized();
-      return get_version() > pack_version(2, 0, 10);
-    }
-
-    bool device_trezor::is_live_refresh_enabled() const
-    {
-      return is_live_refresh_supported() && (mode == NONE || mode == TRANSACTION_PARSE) && m_live_refresh_enabled;
-    }
-
-    bool device_trezor::has_ki_live_refresh() const
-    {
-      try{
-        return is_live_refresh_enabled();
-      } catch(const std::exception & e){
-        MERROR("Could not detect if live refresh is enabled: " << e.what());
-      }
-      return false;
-    }
-
-    void device_trezor::live_refresh_start()
-    {
-      TREZOR_AUTO_LOCK_CMD();
-      require_connected();
-      live_refresh_start_unsafe();
-    }
-
-    void device_trezor::live_refresh_start_unsafe()
-    {
-      device_state_reset_unsafe();
-      require_initialized();
-
-      auto req = std::make_shared<messages::monero::MoneroLiveRefreshStartRequest>();
-      this->set_msg_addr<messages::monero::MoneroLiveRefreshStartRequest>(req.get());
-      this->client_exchange<messages::monero::MoneroLiveRefreshStartAck>(req);
-      m_live_refresh_in_progress = true;
-      m_last_live_refresh_time = std::chrono::steady_clock::now();
-    }
-
-    void device_trezor::live_refresh(
-        const ::crypto::secret_key & view_key_priv,
-        const crypto::public_key& out_key,
-        const crypto::key_derivation& recv_derivation,
-        size_t real_output_index,
-        const cryptonote::subaddress_index& received_index,
-        cryptonote::keypair& in_ephemeral,
-        crypto::key_image& ki
-    )
-    {
-      TREZOR_AUTO_LOCK_CMD();
-      require_connected();
-
-      if (!m_live_refresh_in_progress)
-      {
-        live_refresh_start_unsafe();
-      }
-
-      m_last_live_refresh_time = std::chrono::steady_clock::now();
-
-      auto req = std::make_shared<messages::monero::MoneroLiveRefreshStepRequest>();
-      req->set_out_key(out_key.data, 32);
-      req->set_recv_deriv(recv_derivation.data, 32);
-      req->set_real_out_idx(real_output_index);
-      req->set_sub_addr_major(received_index.major);
-      req->set_sub_addr_minor(received_index.minor);
-
-      auto ack = this->client_exchange<messages::monero::MoneroLiveRefreshStepAck>(req);
-      protocol::ki::live_refresh_ack(view_key_priv, out_key, ack, in_ephemeral, ki);
-    }
-
-    void device_trezor::live_refresh_finish_unsafe()
-    {
-      auto req = std::make_shared<messages::monero::MoneroLiveRefreshFinalRequest>();
-      this->client_exchange<messages::monero::MoneroLiveRefreshFinalAck>(req);
-      m_live_refresh_in_progress = false;
-    }
-
-    void device_trezor::live_refresh_finish()
-    {
-      TREZOR_AUTO_LOCK_CMD();
-      require_connected();
-      if (m_live_refresh_in_progress)
-      {
-        live_refresh_finish_unsafe();
-      }
-    }
-
-    void device_trezor::computing_key_images(bool started)
-    {
-      try
-      {
-        if (!is_live_refresh_enabled())
-        {
-          return;
-        }
-
-        // React only on termination as the process can auto-start itself.
-        if (!started && m_live_refresh_in_progress)
-        {
-          live_refresh_finish();
-        }
-      }
-      catch(const std::exception & e)
-      {
-        MWARNING("KI computation state change failed, started: " << started << ", e: " << e.what());
-      }
-    }
-
-    bool device_trezor::compute_key_image(
-        const ::cryptonote::account_keys& ack,
-        const ::crypto::public_key& out_key,
-        const ::crypto::key_derivation& recv_derivation,
-        size_t real_output_index,
-        const ::cryptonote::subaddress_index& received_index,
-        ::cryptonote::keypair& in_ephemeral,
-        ::crypto::key_image& ki)
-    {
-      if (!is_live_refresh_enabled())
-      {
-        return false;
-      }
-
-      live_refresh(ack.m_view_secret_key, out_key, recv_derivation, real_output_index, received_index, in_ephemeral, ki);
-      return true;
-    }
 
     void device_trezor::tx_sign(wallet_shim * wallet,
                                 const tools::wallet2::unsigned_tx_set & unsigned_tx,
@@ -473,15 +215,7 @@
                                 hw::tx_aux_data & aux_data)
     {
       CHECK_AND_ASSERT_THROW_MES(unsigned_tx.transfers.first == 0, "Unsuported non zero offset");
-
-      TREZOR_AUTO_LOCK_CMD();
-      require_connected();
-      device_state_reset_unsafe();
-      require_initialized();
-      transaction_versions_check(unsigned_tx, aux_data);
-
-      const size_t num_tx = unsigned_tx.txes.size();
-      m_num_transations_to_sign = num_tx;
+      size_t num_tx = unsigned_tx.txes.size();
       signed_tx.key_images.clear();
       signed_tx.key_images.resize(unsigned_tx.transfers.second.size());
 
@@ -526,10 +260,6 @@
         cpend.key_images = key_images;
 
         // KI sync
-        for(size_t cidx=0, trans_max=unsigned_tx.transfers.second.size(); cidx < trans_max; ++cidx){
-          signed_tx.key_images[cidx] = unsigned_tx.transfers.second[cidx].m_key_image;
-        }
-
         size_t num_sources = cdata.tx_data.sources.size();
         CHECK_AND_ASSERT_THROW_MES(num_sources == cdata.source_permutation.size(), "Invalid permutation size");
         CHECK_AND_ASSERT_THROW_MES(num_sources == cdata.tx.vin.size(), "Invalid tx.vin size");
@@ -539,19 +269,12 @@
           CHECK_AND_ASSERT_THROW_MES(src_idx < cdata.tx.vin.size(), "Invalid idx_mapped");
 
           size_t idx_map_src = cdata.tx_data.selected_transfers[idx_mapped];
-          CHECK_AND_ASSERT_THROW_MES(idx_map_src >= unsigned_tx.transfers.first, "Invalid offset");
+          auto vini = boost::get<cryptonote::txin_to_key>(cdata.tx.vin[src_idx]);
 
-          idx_map_src -= unsigned_tx.transfers.first;
           CHECK_AND_ASSERT_THROW_MES(idx_map_src < signed_tx.key_images.size(), "Invalid key image index");
-
-          const auto vini = boost::get<cryptonote::txin_to_key>(cdata.tx.vin[src_idx]);
           signed_tx.key_images[idx_map_src] = vini.k_image;
         }
       }
-
-      if (m_callback){
-        m_callback->on_progress(device_cold::tx_progress(m_num_transations_to_sign, m_num_transations_to_sign, 1, 1, 1, 1));
-      }
     }
 
     void device_trezor::tx_sign(wallet_shim * wallet,
@@ -560,16 +283,10 @@
                    hw::tx_aux_data & aux_data,
                    std::shared_ptr<protocol::tx::Signer> & signer)
     {
-#define EVENT_PROGRESS(S, SUB, SUBMAX) do { if (m_callback) { \
-      (m_callback)->on_progress(device_cold::tx_progress(idx, m_num_transations_to_sign, S, 10, SUB, SUBMAX)); \
-} }while(0)
-
+      AUTO_LOCK_CMD();
       require_connected();
-      if (idx > 0)
-        device_state_reset_unsafe();
-
+      device_state_reset_unsafe();
       require_initialized();
-      EVENT_PROGRESS(0, 1, 1);
 
       CHECK_AND_ASSERT_THROW_MES(idx < unsigned_tx.txes.size(), "Invalid transaction index");
       signer = std::make_shared<protocol::tx::Signer>(wallet, &unsigned_tx, idx, &aux_data);
@@ -581,7 +298,6 @@
       auto init_msg = signer->step_init();
       this->set_msg_addr(init_msg.get());
       transaction_pre_check(init_msg);
-      EVENT_PROGRESS(1, 1, 1);
 
       auto response = this->client_exchange<messages::monero::MoneroTransactionInitAck>(init_msg);
       signer->step_init_ack(response);
@@ -591,7 +307,6 @@
         auto src = signer->step_set_input(cur_src);
         auto ack = this->client_exchange<messages::monero::MoneroTransactionSetInputAck>(src);
         signer->step_set_input_ack(ack);
-        EVENT_PROGRESS(2, cur_src, num_sources);
       }
 
       // Step: sort
@@ -600,82 +315,44 @@
         auto perm_ack = this->client_exchange<messages::monero::MoneroTransactionInputsPermutationAck>(perm_req);
         signer->step_permutation_ack(perm_ack);
       }
-      EVENT_PROGRESS(3, 1, 1);
 
       // Step: input_vini
-      for(size_t cur_src = 0; cur_src < num_sources; ++cur_src){
-        auto src = signer->step_set_vini_input(cur_src);
-        auto ack = this->client_exchange<messages::monero::MoneroTransactionInputViniAck>(src);
-        signer->step_set_vini_input_ack(ack);
-        EVENT_PROGRESS(4, cur_src, num_sources);
+      if (!signer->in_memory()){
+        for(size_t cur_src = 0; cur_src < num_sources; ++cur_src){
+          auto src = signer->step_set_vini_input(cur_src);
+          auto ack = this->client_exchange<messages::monero::MoneroTransactionInputViniAck>(src);
+          signer->step_set_vini_input_ack(ack);
+        }
       }
 
       // Step: all inputs set
       auto all_inputs_set = signer->step_all_inputs_set();
       auto ack_all_inputs = this->client_exchange<messages::monero::MoneroTransactionAllInputsSetAck>(all_inputs_set);
       signer->step_all_inputs_set_ack(ack_all_inputs);
-      EVENT_PROGRESS(5, 1, 1);
 
       // Step: outputs
       for(size_t cur_dst = 0; cur_dst < num_outputs; ++cur_dst){
         auto src = signer->step_set_output(cur_dst);
         auto ack = this->client_exchange<messages::monero::MoneroTransactionSetOutputAck>(src);
         signer->step_set_output_ack(ack);
-
-        // If BP is offloaded to host, another step with computed BP may be needed.
-        auto offloaded_bp = signer->step_rsig(cur_dst);
-        if (offloaded_bp){
-          auto bp_ack = this->client_exchange<messages::monero::MoneroTransactionSetOutputAck>(offloaded_bp);
-          signer->step_set_rsig_ack(ack);
-        }
-
-        EVENT_PROGRESS(6, cur_dst, num_outputs);
       }
 
       // Step: all outs set
       auto all_out_set = signer->step_all_outs_set();
       auto ack_all_out_set = this->client_exchange<messages::monero::MoneroTransactionAllOutSetAck>(all_out_set);
       signer->step_all_outs_set_ack(ack_all_out_set, *this);
-      EVENT_PROGRESS(7, 1, 1);
 
       // Step: sign each input
       for(size_t cur_src = 0; cur_src < num_sources; ++cur_src){
         auto src = signer->step_sign_input(cur_src);
         auto ack_sign = this->client_exchange<messages::monero::MoneroTransactionSignInputAck>(src);
         signer->step_sign_input_ack(ack_sign);
-        EVENT_PROGRESS(8, cur_src, num_sources);
       }
 
       // Step: final
       auto final_msg = signer->step_final();
       auto ack_final = this->client_exchange<messages::monero::MoneroTransactionFinalAck>(final_msg);
       signer->step_final_ack(ack_final);
-      EVENT_PROGRESS(9, 1, 1);
-#undef EVENT_PROGRESS
-    }
-
-    void device_trezor::transaction_versions_check(const ::tools::wallet2::unsigned_tx_set & unsigned_tx, hw::tx_aux_data & aux_data)
-    {
-      auto trezor_version = get_version();
-      unsigned client_version = 1;  // default client version for tx
-
-      if (trezor_version <= pack_version(2, 0, 10)){
-        client_version = 0;
-      }
-
-      if (aux_data.client_version){
-        auto wanted_client_version = aux_data.client_version.get();
-        if (wanted_client_version > client_version){
-          throw exc::TrezorException("Trezor firmware 2.0.10 and lower does not support current transaction sign protocol. Please update.");
-        } else {
-          client_version = wanted_client_version;
-        }
-      }
-      aux_data.client_version = client_version;
-
-      if (client_version == 0 && aux_data.bp_version && aux_data.bp_version.get() != 1){
-        throw exc::TrezorException("Trezor firmware 2.0.10 and lower does not support current transaction sign protocol (BPv2+). Please update.");
-      }
     }
 
     void device_trezor::transaction_pre_check(std::shared_ptr<messages::monero::MoneroTransactionInitRequest> init_msg)
@@ -685,9 +362,13 @@
       CHECK_AND_ASSERT_THROW_MES(m_features, "Device state not initialized");  // make sure the caller did not reset features
       const bool nonce_required = init_msg->tsx_data().has_payment_id() && init_msg->tsx_data().payment_id().size() > 0;
 
-      if (nonce_required && init_msg->tsx_data().payment_id().size() == 8){
+      if (nonce_required){
         // Versions 2.0.9 and lower do not support payment ID
-        if (get_version() <= pack_version(2, 0, 9)) {
+        CHECK_AND_ASSERT_THROW_MES(m_features->has_major_version() && m_features->has_minor_version() && m_features->has_patch_version(), "Invalid Trezor firmware version information");
+        const uint32_t vma = m_features->major_version();
+        const uint32_t vmi = m_features->minor_version();
+        const uint32_t vpa = m_features->patch_version();
+        if (vma < 2 || (vma == 2 && vmi == 0 && vpa <= 9)) {
           throw exc::TrezorException("Trezor firmware 2.0.9 and lower does not support transactions with short payment IDs or integrated addresses. Please update.");
         }
       }
@@ -712,7 +393,7 @@
 
       const bool nonce_required = tdata.tsx_data.has_payment_id() && tdata.tsx_data.payment_id().size() > 0;
       const bool has_nonce = cryptonote::find_tx_extra_field_by_type(tx_extra_fields, nonce);
-      CHECK_AND_ASSERT_THROW_MES(has_nonce || !nonce_required, "Transaction nonce not present");
+      CHECK_AND_ASSERT_THROW_MES(has_nonce == nonce_required, "Transaction nonce presence inconsistent");
 
       if (nonce_required){
         const std::string & payment_id = tdata.tsx_data.payment_id();
