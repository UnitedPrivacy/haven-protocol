--- monero/src/cryptonote_basic/cryptonote_format_utils.cpp	2019-06-20 21:03:18.730816602 +0100
+++ haven/src/cryptonote_basic/cryptonote_format_utils.cpp	2019-06-17 17:10:44.681734943 +0100
@@ -928,15 +923,15 @@
     switch (decimal_point)
     {
       case 12:
-        return "monero";
+        return "haven";
       case 9:
-        return "millinero";
+        return "millihaven";
       case 6:
-        return "micronero";
+        return "microhaven";
       case 3:
-        return "nanonero";
+        return "nanohaven";
       case 0:
-        return "piconero";
+        return "picohaven";
       default:
         ASSERT_MES_AND_THROW("Invalid decimal point specification: " << decimal_point);
     }
@@ -1040,10 +1041,7 @@
     }
 
     // prunable rct
-    if (t.rct_signatures.type == rct::RCTTypeNull)
-      hashes[2] = crypto::null_hash;
-    else
-      hashes[2] = pruned_data_hash;
+    hashes[2] = pruned_data_hash;
 
     // the tx hash is the hash of the 3 hashes
     crypto::hash res = cn_fast_hash(hashes, sizeof(hashes));
@@ -1065,6 +1063,8 @@
     // prefix
     get_transaction_prefix_hash(t, hashes[0]);
 
+    transaction &tt = const_cast<transaction&>(t);
+
     const blobdata blob = tx_to_blob(t);
     const unsigned int unprunable_size = t.unprunable_size;
     const unsigned int prefix_size = t.prefix_size;
@@ -1088,14 +1088,7 @@
 
     // we still need the size
     if (blob_size)
-    {
-      if (!t.is_blob_size_valid())
-      {
-        t.blob_size = blob.size();
-        t.set_blob_size_valid(true);
-      }
-      *blob_size = t.blob_size;
-    }
+      *blob_size = get_object_blobsize(t);
 
     return true;
   }
@@ -1148,37 +1141,21 @@
     return blob;
   }
   //---------------------------------------------------------------
-  bool calculate_block_hash(const block& b, crypto::hash& res, const blobdata *blob)
+  bool calculate_block_hash(const block& b, crypto::hash& res)
   {
-    blobdata bd;
-    if (!blob)
-    {
-      bd = block_to_blob(b);
-      blob = &bd;
-    }
-
-    bool hash_result = get_object_hash(get_block_hashing_blob(b), res);
-    if (!hash_result)
-      return false;
-
-    if (b.miner_tx.vin.size() == 1 && b.miner_tx.vin[0].type() == typeid(cryptonote::txin_gen))
-    {
-      const cryptonote::txin_gen &txin_gen = boost::get<cryptonote::txin_gen>(b.miner_tx.vin[0]);
-      if (txin_gen.height != 202612)
-        return true;
-    }
-
     // EXCEPTION FOR BLOCK 202612
     const std::string correct_blob_hash_202612 = "3a8a2b3a29b50fc86ff73dd087ea43c6f0d6b8f936c849194d5c84c737903966";
     const std::string existing_block_id_202612 = "bbd604d2ba11ba27935e006ed39c9bfdd99b76bf4a50654bc1e1e61217962698";
-    crypto::hash block_blob_hash = get_blob_hash(*blob);
+    crypto::hash block_blob_hash = get_blob_hash(block_to_blob(b));
 
     if (string_tools::pod_to_hex(block_blob_hash) == correct_blob_hash_202612)
     {
       string_tools::hex_to_pod(existing_block_id_202612, res);
       return true;
     }
+    bool hash_result = get_object_hash(get_block_hashing_blob(b), res);
 
+    if (hash_result)
     {
       // make sure that we aren't looking at a block with the 202612 block id but not the correct blobdata
       if (string_tools::pod_to_hex(res) == existing_block_id_202612)
@@ -1218,19 +1195,25 @@
     return p;
   }
   //---------------------------------------------------------------
-  bool get_block_longhash(const block& b, crypto::hash& res, uint64_t height)
-  {
-    // block 202612 bug workaround
-    if (height == 202612)
+  bool get_block_longhash(const block& b, cn_pow_hash_v3 &ctx, crypto::hash& res)
     {
-      static const std::string longhash_202612 = "84f64766475d51837ac9efbef1926486e58563c95a19fef4aec3254f03000000";
-      string_tools::hex_to_pod(longhash_202612, res);
-      return true;
-    }
-    blobdata bd = get_block_hashing_blob(b);
-    const int cn_variant = b.major_version >= 7 ? b.major_version - 6 : 0;
-    crypto::cn_slow_hash(bd.data(), bd.size(), res, cn_variant, height);
-    return true;
+  	block b_local = b; //workaround to avoid const errors with do_serialize
+  	blobdata bd = get_block_hashing_blob(b);
+  	if(b_local.major_version >= CRYPTONOTE_V3_POW_BLOCK_VERSION)
+  	{
+      ctx.hash(bd.data(), bd.size(), res.data);
+  	}
+  	else if(b_local.major_version == CRYPTONOTE_V2_POW_BLOCK_VERSION)
+  	{
+      cn_pow_hash_v2 ctx_v2 = cn_pow_hash_v2::make_borrowed_v2(ctx);
+      ctx_v2.hash(bd.data(), bd.size(), res.data);
+  	}
+  	else
+  	{
+      cn_pow_hash_v1 ctx_v1 = cn_pow_hash_v1::make_borrowed_v1(ctx);
+      ctx_v1.hash(bd.data(), bd.size(), res.data);
+  	}
+  	return true;
   }
   //---------------------------------------------------------------
   std::vector<uint64_t> relative_output_offsets_to_absolute(const std::vector<uint64_t>& off)
@@ -1352,7 +1310,8 @@
   crypto::secret_key encrypt_key(crypto::secret_key key, const epee::wipeable_string &passphrase)
   {
     crypto::hash hash;
-    crypto::cn_slow_hash(passphrase.data(), passphrase.size(), hash);
+    cn_pow_hash_v3 cph;
+    cph.hash(passphrase.data(), passphrase.size(), hash.data);
     sc_add((unsigned char*)key.data, (const unsigned char*)key.data, (const unsigned char*)hash.data);
     return key;
   }
@@ -1360,7 +1319,8 @@
   crypto::secret_key decrypt_key(crypto::secret_key key, const epee::wipeable_string &passphrase)
   {
     crypto::hash hash;
-    crypto::cn_slow_hash(passphrase.data(), passphrase.size(), hash);
+    cn_pow_hash_v3 cph;
+    cph.hash(passphrase.data(), passphrase.size(), hash.data);
     sc_sub((unsigned char*)key.data, (const unsigned char*)key.data, (const unsigned char*)hash.data);
     return key;
   }
